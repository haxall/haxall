//
// Copyright (c) 2025, Brian Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   16 Dec 2025  Brian Frank  Creation
//

using concurrent
using xeto
using haystack

**
** CompMap is an optimize data structure to manage a list of Comps.
** It supports the following features:
**   - generation of ids using simple incrementing counter
**   - hashmap storage/lookup of components by id
**   - sorting by topology using Kahn's Algorithm (inputs -> outputs)
**
@Js
class CompMap
{

//////////////////////////////////////////////////////////////////////////
// Index
//////////////////////////////////////////////////////////////////////////

  ** Generate an id with the context of a CompFactory swizzle operation
  Ref genId()
  {
    id := Ref(counter.toStr)
    ++counter
    return id
  }

  ** Size
  Int size() { byId.size }

  ** Get component by id or return null
  Comp? get(Ref id) { byId.get(id) }

  ** Add component to the index using id generated by genId
  Void add(Comp c) { byId.add(c.id, c); topologyChanged }

  ** Remove component from index
  Void remove(Comp c) { byId.remove(c.id); topologyChanged }

  ** Iterate comps
  Void each(|Comp| f) { byId.each(f) }

//////////////////////////////////////////////////////////////////////////
// Topological Sort
//////////////////////////////////////////////////////////////////////////

  ** Clear topology sort
  Void topologyChanged()
  {
    byTopology = null
  }

  ** Return comps in topological sort order from inputs to outputs
  Comp[] topology()
  {
    if (byTopology == null) byTopology = sortByTopology.ro
    return byTopology
  }

  ** Compute topological sort order using Kahn's algorithm
  private Comp[] sortByTopology()
  {
    // build index of nodes and clear old pushTo links
    nodes := Ref:CompMapSortNode[:]
    byId.each |c|
    {
      node := CompMapSortNode(c.id, c)
      node.spi.clearPushTo
      nodes[c.id] = node
    }

    // now compute each node's inDegree and outputs we push to
    nodes.each |node|
    {
      // check if node has links
      links := node.comp.links
      if (links.isEmpty) return

      // process each link into this node
      links.eachLink |toSlot, link|
      {
        // lookup the from node of this link
        from := nodes.get(link.fromRef)
        if (from == null) return

        // update my own incoming link degree
        node.inDegree++

        // add my own id to the from node
        from.addOutId(node.id)

        // add fat slot pushTo on from comp
        from.spi.fatten(link.fromSlot).addPushTo(node.comp, toSlot)
      }
    }

    // build a queue of all nodes with zero in degree
    queue := CompMapSortNode[,]
    nodes.each |node|
    {
      if (node.inDegree == 0) queue.push(node)
    }
    queue.reverse

    // now we recursively process the queue to work our way
    // through the topological graph using Kahnâ€™s algorithm
    acc := Comp[,]
    acc.capacity = byId.size
    while (!queue.isEmpty)
    {
      // pop next node and accumulate it
      node := queue.pop
      node.accumulated = true
      acc.add(node.comp)

      // now decrement every adjacent node and if its inDegree
      // drops to zero then add it to our queue
      node.outIds.each |x|
      {
        toNode := nodes.getChecked(x)
        toNode.inDegree--
        if (toNode.inDegree == 0) queue.push(toNode)
      }
    }

    // add anything left over which indicates cyclic links
    nodes.each |node|
    {
      if (!node.accumulated) acc.add(node.comp)
    }

    return acc
  }

  ** Debug dump the topology graph
  Void dumpTopology(OutStream out)
  {
    topology.each |c|
    {
      spi := (MCompSpi)c.spi
      out.printLine(c.toStr)
      spi.eachFat |fat, n|
      {
        tos := FatSlotPushTo[,]
        fat.eachPushTo |x| { tos.add(x) }
        if (tos.isEmpty) return
        out.printLine("  $n -> $tos")
      }
    }
  }

//////////////////////////////////////////////////////////////////////////
// Fields
//////////////////////////////////////////////////////////////////////////

  private Ref:Comp byId := Ref:Comp[:]
  private Comp[]? byTopology
  private Int counter
}

**************************************************************************
** CompMapSortNode
**************************************************************************

@Js
internal class CompMapSortNode
{
  new make(Ref id, Comp comp)
  {
    this.id     = id
    this.comp   = comp
    this.spi    = comp.spi
    this.outIds = emptyIds
  }

  static const Ref[] emptyIds := Ref[,]

  Void addOutId(Ref x)
  {
    if (outIds.isEmpty) outIds = Ref[,]
    outIds.add(x)
  }

  Ref id            // component id
  Comp comp         // component
  MCompSpi spi      // service provider interface
  Int inDegree      // number of incoming links
  Ref[] outIds      // id to targets of outgoing links
  Bool accumulated  // have we accumulated into results

  override Str toStr() { "$id inDegree=$inDegree $outIds" }
}

