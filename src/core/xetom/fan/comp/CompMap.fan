//
// Copyright (c) 2025, Brian Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   16 Dec 2025  Brian Frank  Creation
//

using concurrent
using xeto
using haystack

**
** CompMap is an optimize data structure to manage a list of Comps.
** It supports the following features:
**   - id assignment for mounting new comps (swizzled by CompFactory)
**   - id are composed of "{index}[.{counter}]"
**   - fast lookup against list via index portion of id
**   - sorting by topology using Kahn's Algorithm (inputs -> outputs)
**
@Js
class CompMap
{

//////////////////////////////////////////////////////////////////////////
// Index
//////////////////////////////////////////////////////////////////////////

  ** Generate an id with the context of a CompFactory swizzle operation
  Ref genId(Ref? prev)
  {
    // find next free slot in index
    start := prev == null ? 0 : idToIndex(prev) + 1
    for (i := start; i<index.size; ++i)
    {
      if (index[i] == null) return indexToId(i, counter++)
    }

    // need to grow index
    i := index.size
    index.size = (index.size * 2).max(8)
    return indexToId(i, counter++)
  }

  ** Size
  Int size() { sizeRef }

  ** Get component by id or return null
  Comp? get(Ref id)
  {
    i := idToIndex(id, false)
    if (i < 0 || i >= index.size) return null
    return index[i]
  }

  ** Add component to the index using id generated by genId
  Void add(Comp c)
  {
    id := c.id
    i := idToIndex(id)
    if (i >= index.size) throw Err("Id not from genId: $id")
    if (index[i] != null) throw Err("Dup CompMap index: $id")
    index[i] = c
    sizeRef++
    topologyChanged
  }

  ** Remove component from index
  Void remove(Comp c)
  {
    id := c.id
    i := idToIndex(id)
    if (index[i] !== c) throw Err("Not in CompMap: $id")
    index[i] = null
    sizeRef--
    topologyChanged
  }

  ** Iterate comps
  Void each(|Comp| f)
  {
    index.eachNotNull(f)
  }

//////////////////////////////////////////////////////////////////////////
// Topological Sort
//////////////////////////////////////////////////////////////////////////

  ** Clear topology sort
  Void topologyChanged()
  {
    sorted = null
  }

  ** Return comps in topological sort order from inputs to outputs
  Comp[] topology()
  {
    if (sorted == null) sorted = sort.ro
    return sorted
  }

  ** Compute topological sort order using Kahn's algorithm
  private Comp[] sort()
  {
    // build index of nodes with direct list indexing
    nodes := CompMapSortNode?[,]
    nodes.size = index.size
    index.eachNotNull |c, idx| { nodes[idx] = CompMapSortNode(idx, c) }

    // now compute each node's inDegree and outIndexes
    nodes.eachNotNull |node|
    {
      // process each link into this node
      links := node.comp.links
      if (links.isEmpty) return
      links.eachLink |slot, link|
      {
        // lookup the from node of this link
        fromIndex := idToIndex(link.fromRef, false)
        if (fromIndex < 0) return
        from := nodes.getSafe(fromIndex)
        if (from == null) return

        // update my own incoming link degree
        node.inDegree++

        // add my own index to the from node
        from.addOutIndex(node.index)
      }
    }

    // build a queue of all nodes with zero in degree; walk in
    // reverse so this initial queue is processed from top to bottom
    queue := CompMapSortNode[,]
    nodes.eachr |node|
    {
      if (node != null && node.inDegree == 0) queue.push(node)
    }

    // now we recursively process the queue to work our way
    // through the topological graph using Kahnâ€™s algorithm
    acc := Comp[,]
    acc.capacity = sizeRef
    while (!queue.isEmpty)
    {
      // pop next node and accumulate it
      node := queue.pop
      node.accumulated = true
      acc.add(node.comp)

      // now decrement every adjacent node and if its inDegree
      // drops to zero then add it to our queue
      node.outIndexes.each |idx|
      {
        toNode := nodes[idx]
        toNode.inDegree--
        if (toNode.inDegree == 0) queue.push(toNode)
      }
    }

    // add anything left over which indicates cyclic links
    nodes.eachNotNull |node|
    {
      if (!node.accumulated) acc.add(node.comp)
    }

    return acc
  }

//////////////////////////////////////////////////////////////////////////
// Id Utils
//////////////////////////////////////////////////////////////////////////

  static Ref indexToId(Int index, Int counter)
  {
    i := index.toHex
    if (index == counter) return Ref(i)
    c := counter.toHex
    return Ref.makeImpl(StrBuf(i.size + 1 + c.size).add(i).addChar('.').add(c).toStr, null)
  }

  static Int idToIndex(Ref id, Bool checked := true)
  {
    s := id.id
    index := 0
    for (i := 0; i<s.size; ++i)
    {
      c := s[i]
      if (c == '.' && i > 0) break
      nibble := c.fromDigit(16)
      if (nibble == null)
      {
        if (checked) throw Err("Invalid CompMap id: $id.toCode")
        return -1
      }
      index = index.shiftl(4).or(nibble)
    }
    return index
  }

//////////////////////////////////////////////////////////////////////////
// Fields
//////////////////////////////////////////////////////////////////////////

  private Comp?[] index := Comp?[,]
  private Comp[]? sorted
  private Int sizeRef
  private Int counter
}

**************************************************************************
** CompMapSortNode
**************************************************************************

@Js
internal class CompMapSortNode
{
  new make(Int index, Comp comp)
  {
    this.index      = index
    this.comp       = comp
    this.outIndexes = emptyInts
  }

  static const Int[] emptyInts := Int[,]

  Void addOutIndex(Int index)
  {
    if (outIndexes.isEmpty) outIndexes = Int[,]
    outIndexes.add(index)
  }

  Int index         // component id index
  Comp comp         // component
  Int inDegree      // number of incoming links
  Int[] outIndexes  // index to targets of outgoing links
  Bool accumulated  // have we accumulated into results

  override Str toStr() { "$index inDegree=$inDegree $outIndexes" }
}

