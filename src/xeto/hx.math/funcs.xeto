//
// Copyright (c) 2025, SkyFoundry LLC
// Licensed under the Academic Free License version 3.0
//
// History:
//   18 Jul 2025  Brian Frank  Creation
//

+Funcs {

  // Return constant for pi: 3.141592653589793
  pi: Func { returns: Number }

  // Return the remainder or modulo of division: 'a % b'.
  // Result has same unit as 'a'.
  remainder: Func { a: Number, b: Number, returns: Number }

  // Return the smallest whole number greater than or equal to val.
  // Result has same unit as 'val'.
  ceil: Func { val: Number, returns: Number }

  // Return the largest whole number less than or equal to val.
  // Result has same unit as 'val'.
  floor: Func { val: Number, returns: Number }

  // Returns the nearest whole number to val.
  // Result has same unit as 'val'.
  round: Func { val: Number, returns: Number }

  // Return e raised to val.
  exp: Func { val: Number, returns: Number }

  // Return natural logarithm to the base e of val.
  logE: Func { val: Number, returns: Number }

  // Return base 10 logarithm of val.
  log10: Func { val: Number, returns: Number }

  // Return val raised to the specified power.
  pow: Func { val: Number, exp: Number, returns: Number }

  // Return square root of val.
  sqrt: Func { val: Number, returns: Number }

  // Return random integer within given inclusive range.
  // If range is null, then full range of representative
  // integers is assumed.
  //
  // Examples:
  //    random()       // random num with no range
  //    random(0..100) // random num between 0 and 100
  random: Func { range: Obj?, returns: Number }

  // Bitwise not: '~a'
  bitNot: Func { a: Number, returns: Number }

  // Bitwise and: 'a & b'
  bitAnd: Func { a: Number, b: Number, returns: Number }

  // Bitwise or: 'a | b'
  bitOr: Func { a: Number, b: Number, returns: Number }

  // Bitwise xor: 'a ^ b'
  bitXor: Func { a: Number, b: Number, returns: Number }

  // Bitwise right shift: 'a >> b'
  bitShiftr: Func { a: Number, b: Number, returns: Number }

  // Bitwise left shift: 'a << b'
  bitShiftl: Func { a: Number, b: Number, returns: Number }

  // Return the arc cosine.
  acos: Func { val: Number, returns: Number }

  // Return the arc sine.
  asin: Func { val: Number, returns: Number }

  // Return the arc tangent.
  atan: Func { val: Number, returns: Number }

  // Converts rectangular coordinates (x, y) to polar (r, theta).
  atan2: Func { y: Number, x: Number, returns: Number }

  // Return the cosine of angle in radians.
  cos: Func { val: Number, returns: Number }

  // Return the hyperbolic cosine.
  cosh: Func { val: Number, returns: Number }

  // Return sine of angle in radians.
  sin: Func { val: Number, returns: Number }

  // Return hyperbolic sine.
  sinh: Func { val: Number, returns: Number }

  // Return tangent of angle in radians.
  tan: Func { val: Number, returns: Number }

  // Return hyperbolic tangent.
  tanh: Func { val: Number, returns: Number }

  // Convert angle in radians to an angle in degrees.
  toDegrees: Func { val: Number, returns: Number }

  // Convert angle in degrees to an angle in radians.
  toRadians: Func { val: Number, returns: Number }

  // Fold a sample of numbers into their standard average or arithmetic
  // mean.  This function is the same as [core::avg]`avg()`.  Nulls
  // values are ignored.  Return null if no values.
  //
  // Example:
  //   [2, 4, 5, 3].fold(mean)
  mean: Func <foldOn:"Number"> { val: Obj?, acc: Obj?, returns: Obj? }

  // Fold a sample of numbers into their median value which is the
  // middle value of the sorted samples.  If there are an even number
  // of sample, then the median is the mean of the middle two.  Null
  // values are ignored.  Return null if no values.
  //
  // Example:
  //   [2, 4, 5, 3, 1].fold(median)
  median: Func <foldOn:"Number"> { val: Obj?, acc: Obj?, returns: Obj? }

  // Fold a sample of numbers into their RMSE (root mean square error).
  // The RMSE function determines the RMSE between a sample set and
  // its mean using the n-degrees of freedom RMSE:
  //
  //   RMBE = sqrt( Σ(xᵢ - median)² ) / (n - nDegrees)
  //
  // Examples:
  //   samples.fold(rootMeanSquareErr)         // unbiased zero degrees of freedom
  //   samples.fold(rootMeanSquareErr(_,_,1))  // 1 degree of freedom
  rootMeanSquareErr: Func <foldOn:"Number"> { val: Obj?, acc: Obj?, nDegrees: Number, returns: Obj? }

  // Fold a sample of numbers into their MBE (mean bias error).
  // The MBE function determines the MBE between a sample set and
  // its mean:
  //
  //   MBE = Σ(xᵢ - median) / (n - nDegrees)
  //
  // Examples:
  //   samples.fold(meanBiasErr)         // unbiased zero degrees of freedom
  //   samples.fold(meanBiasErr(_,_,1))  // 1 degree of freedom
  meanBiasErr: Func <foldOn:"Number"> { val: Obj?, acc: Obj?, nDegrees: Number, returns: Obj? }

  // Fold a series of numbers into the standard deviation of a *sample*:
  //
  //   s = sqrt(Σ (xᵢ - mean)² / (n-1))
  //
  // Example:
  //   [4, 2, 5, 8, 6].fold(standardDeviation)
  standardDeviation: Func <foldOn:"Number"> { val: Obj?, acc: Obj?, returns: Obj? }

  // Computes the p*th* quantile of a list of numbers, according to the specified interpolation method.
  // The value p must be a number between 0.0 to 1.0.
  //
  //  - **linear** (default): Interpolates proportionally between the two closest values
  //  - **nearest**: Rounds to the nearest data point
  //  - **lower**: Rounds to the nearest lower data point
  //  - **higher**: Rounds to the nearest higher data point
  //  - **midpoint**: Averages two nearest values
  //
  // Usage:
  //   [1,2,3].fold(quantile(p, method))
  //
  // Examples:
  //   [10,10,10,25,100].fold(quantile(0.7 )) => 22 //default to linear
  //   [10,10,10,25,100].fold(quantile(0.7, "nearest")) => 25
  //   [10,10,10,25,100].fold(quantile(0.7, "lower")) => 10
  //   [10,10,10,25,100].fold(quantile(0.7, "higher")) => 25
  //   [10,10,10,25,100].fold(quantile(0.7, "linear")) => 22 //same as no arg
  //   [10,10,10,25,100].fold(quantile(0.7, "midpoint")) => 17.5
  //
  // Detailed Logic:
  //    p: percentile (decimal 0-1)
  //    n: list size
  //    rank: p * (n-1) // this is the index of the percentile in your list
  //    // if rank is an integer, return list[rank]
  //    // if rank is not an integer, interpolate via one of the above methods (illustrated below in examples)
  //
  //    [1,2,3,4,5].percentile(0.5) => 3 // rank=2 is an int so we can index[2] directly
  //
  //    [10,10,10, 25, 100].percentile(0.7, method)
  //      rank = (0.7 * 4) => 2.8
  //
  //      //adjust rank based on method
  //      nearest =  index[3]                // => 25
  //      lower =    index[2]                // => 10
  //      higher =   index[3]                // => 25
  //
  //      //or interpolate for these methods
  //
  //      //takes the 2 closest indices and calculates midpoint
  //      midpoint = (25-10)/2 + 10          // => 17.5
  //
  //      //takes the 2 closest indices and calculates weighted average
  //      linear =   (0.2 * 10) + (0.8 * 25) // => 22
  quantile: Func { percent: Number, method: Str, returns: Obj? }

  quantileFold: Func <nodoc> { val: Obj?, acc: Obj?, perc: Number, method: Str, returns: Obj? }

  // Convert a general grid to an optimized matrix grid.  Matrixs are two
  // dimensional grids of Numbers.  Columns are named "v0", "v1", "v2", etc.
  // Grid meta is preserved, but not column meta.  Numbers in the resulting
  // matrix are unitless; any units passed in are stripped.
  //
  // The following options are supported:
  // - nullVal (Number): replace null values in the grid with this value
  // - naVal (Number): replace NA values in the grid with this value
  //
  // pre>
  //   toMatrix(grid, {nullVal: 0, naVal: 0})
  // <pre
  //
  // To create a sparse or initialized matrix you can pass a Dict with the
  // the following tags (all required)
  //   toMatrix({rows:10, cols: 1000, init: 0})
  toMatrix: Func { obj: Obj, opts: Dict, returns: Grid }

  // Transpose the given matrix which is any value accepted by `toMatrix`.
  matrixTranspose: Func { m: Obj, returns: Grid }

  // Return the determinant as a unitless Number for the given matrix which
  // is any value accepted by `toMatrix`.  The matrix must be square.
  matrixDeterminant: Func { m: Obj, returns: Number }

  // Return the inverse of the given matrix which is any value accepted by `toMatrix`.
  matrixInverse: Func { m: Obj, returns: Grid }

  // Add two matrices together and return new matrix.  The parameters may
  // be any value supported `toMatrix`.  Matrices must have the same dimensions.
  matrixAdd: Func { a: Obj, b: Obj, returns: Grid }

  // Subtract two matrices and return new matrix.  The parameters may
  // be any value supported `toMatrix`.  Matrices must have the same dimensions.
  matrixSub: Func { a: Obj, b: Obj, returns: Grid }

  // Multiply two matrices and return new matrix.  The parameters may
  // be any value supported `toMatrix`.  Matrix 'a' column count must match
  // matrix 'b' row count.
  matrixMult: Func { a: Obj, b: Obj, returns: Grid }

  // Given a matrix of y coordinates and a matrix of multiple x coordinates
  // compute the best fit multiple linear regression equation using
  // the ordinary least squares method.  Both 'y' and 'x' may be any value
  // accepted by `toMatrix`.
  //
  // The resulting linear equation for r X coordinates is:
  //
  //   yᵢ = bias + b₁xᵢ₁ + b₂xᵢ₂ +...+ bᵣxᵢᵣ
  //
  // The equation is returned as a grid.  The grid meta:
  //   - 'bias': bias or zero coefficient which is independent of any of the x factors
  //   - 'r2':  R² coefficient of determination as a number between 1.0 (perfect correlation) and 0.0 (no correlation)
  //   - 'r': the square root of R², referred to as the correlation coefficient
  //   - 'rowCount': the number of rows of data used in the correlation
  // For each X factor there is a row with the following tags:
  //   - 'b': the correlation coefficient for the given X factor
  matrixFitLinearRegression: Func { y: Obj, x: Obj, returns: Grid }

  // Given a grid of x, y coordinates compute the best fit linear
  // regression equation using the ordinary least squares method.
  // The first column of the grid is used for 'x' and the second
  // column is 'y'.  Any rows without a Number for both x and y
  // are skipped.  Any special Numbers (infinity/NaN) are skipped.
  //
  // Options:
  //   - 'x': column name to use for x if not first column
  //   - 'y': column name to use for y if not second column
  //
  // The resulting linear equation is:
  //
  //   yᵢ = mxᵢ + b
  //
  // The equation is returned as a dictionary with these keys:
  //   - 'm': slope of the best fit regression line
  //   - 'b': intercept of the best fit regression line
  //   - 'r2':  R² coefficient of determination as a number between
  //     1.0 (perfect correlation) and 0.0 (no correlation)
  //   - 'xmin': minimum value of x variable in sample data
  //   - 'xmax': maximum value of x variable in sample data
  //   - 'ymin': minimum value of y variable in sample data
  //   - 'ymax': maximum value of y variable in sample data
  //
  // Also see `matrixFitLinearRegression` to compute a multiple linear
  // regression.
  //
  // Example:
  //   data: [{x:1, y:2},
  //          {x:2, y:4},
  //          {x:4, y:4},
  //          {x:6, y:5}].toGrid
  //    fitLinearRegression(data)
  //
  //    >>> {m:0.4915, b: 2.1525, r2: 0.7502}
  fitLinearRegression: Func { grid: Grid, opts: Dict?, returns: Dict }

}
