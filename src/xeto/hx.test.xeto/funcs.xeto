//
// Copyright (c) 2025, SkyFoundry LLC
// Licensed under the Academic Free License version 3.0
//
// History:
//   4 Feb 2025  Brian Frank  Creation
//


//////////////////////////////////////////////////////////////////////////
// APIs
//////////////////////////////////////////////////////////////////////////

+Funcs {

  // ping API
  ping1: Func { returns: Date }

  // ping API (not bound with facet)
  ping2: Func { returns: Date }

  // Axon

  // add in Axon
  add1: Func { a: Number, b: Number, returns: Number
    <axon:"(a, b) => a + b">
  }

  // add in Fantom
  add2: Func { a: Number, b: Number, returns: Number }

  // add in Fantom, but not allowed
  add3: Func { a: Number, b: Number, returns: Number }

  // add in comp blocks
  add4: Func { a: Number, b: Number <compId:"b-id">, returns: Number
    <compTree:---
      @root: Comp {
        @a: Var {}
        @b-id: Var {}
        @returns: Var {
          links: {
            val: Link { fromRef: @add, fromSlot: "out"  }
          }
        }
        @add: TestNumberAdd {
          links: {
            in1: Link { fromRef: @a, fromSlot: "val" }
            in2: Link { fromRef: @b-id, fromSlot: "val" }
          }
        }
      }
      --->
  }

//////////////////////////////////////////////////////////////////////////
// Template - Bind
//////////////////////////////////////////////////////////////////////////

  testTemplateBindA: Template {
    s: Str

    returns: TestFolder {
      dis: "Test"
      foo
      x: Bind <var:"s">
      y: Number 123
    }
  }

  testTemplateBindB: Template {
    data: Dict

    returns: Dict {
      a:  Bind <var:"data.a">
      b:  Bind <var:"data.b">
      c:  Bind <var:"data.c.nest">
      d:  Bind <var:"data.d">
      e:  Bind <var:"data.e">
      en: Bind <var:"data.e.nest">
    }
  }

  testTemplateBindC: Template {
    x: Str
    returns: TestFolder {
      nest: TemplateDictC {
        a: Bind <var:"x">
        e: Bind <var:"x">
      }
    }
  }



testTemplateBindD: Template {
  n: Number
  s: Str
  returns: Dict {
    a: Bind <axon:"n + 100">
    b: Bind <axon:"s.upper">
  }
}

//////////////////////////////////////////////////////////////////////////
// If
//////////////////////////////////////////////////////////////////////////

  testTemplateIfA: Template {
    cond: Bool

    returns: Dict {
      If <var:"cond"> {
        dis: "cond is true"
      }
    }
  }

  testTemplateIfB: Template {
    cond: Bool

    returns: Dict {
      If <var:"cond"> {
        dis: "cond is true"
        yea
      }
      Else {
        dis: "cond is false"
        nay
      }
    }
  }

  testTemplateIfC: Template {
    cond1: Bool
    cond2: Bool

    returns: Dict {
      If <var:"cond1"> {
        dis1: "true"
      }
      Else {
        dis1: "false"
      }
      If <var:"cond2"> {
        dis2: "true"
      }
    }
  }

  testTemplateIfD: Template {
    in: Number

    returns: Dict {
      If <axon:"in > 100"> {
        dis: "greater than 100"
      }
      Else {
        dis: "less than 100"
      }
    }
  }

//////////////////////////////////////////////////////////////////////////
// Template - Switch
//////////////////////////////////////////////////////////////////////////

  testTemplateSwitchA: Template {
    cond: Str

    returns: Dict {
      Switch <var:"cond"> {
        Case <match:"a"> {
          dis:"case a"
          alpha
        }
        Case <match:"b"> {
          dis:"case b"
          beta
        }
        Else {
          dis:"case default"
        }
      }
    }
  }

  testTemplateSwitchB: Template {
    cond: Str

    returns: Dict {
      Switch <axon:"cond.upper"> {
        Case <match:"ALPHA"> {
          dis:"case a"
          alpha
        }
        Case <match:"BETA"> {
          dis:"case b"
          beta
        }
        Else {
          dis:"case default"
        }
      }
    }
  }

  testTemplateSwitchC: Template {
    num1: Number
    num2: Number
    limit: Number

    returns: Dict {
      Switch <var:"num1"> {
        Case <axon:"it.isOdd"> {
          dis1:"odd"
        }
        Case <axon:"it < limit"> {
          dis1: Bind <axon:"\"less than \" + limit">
        }
        Else {
          dis1: Bind <axon:"\"else >= \" + limit">
        }
      }
      Switch <var:"num2"> {
        Case <axon:"it.isOdd"> {
          dis2:"odd"
        }
        Case <axon:"it < limit"> {
          dis2: Bind <axon:"\"less than \" + limit">
        }
        Else {
          dis2: Bind <axon:"\"else >= \" + limit">
        }
      }
    }
  }

//////////////////////////////////////////////////////////////////////////
// Template - Foreach
//////////////////////////////////////////////////////////////////////////

  testTemplateForeachA: Template {
    list: List<of:Str>

    returns: List {
      Foreach <var:"list"> {
        Bind <var:"it">
      }
    }
  }

  testTemplateForeachB: Template {
    list: List<of:Str>

    returns: Dict {
      Foreach <var:"list"> {
        Dict { dis: Bind <var:"it"> }
      }
    }
  }

  testTemplateForeachC: Template {
    data: List<of:Str>

    returns: Dict {
      nestDict: Dict { Foreach <var:"data"> { Bind <var:"it"> } }
      nestList: List { Foreach <var:"data"> { Bind <var:"it"> } }
      nestGrid: Grid { Foreach <var:"data"> { Dict {dis:Bind <var:"it"> } } }
      Foreach <var:"data"> { Bind <var:"it"> }  // spread operator
    }
  }


  testTemplateForeachD: Template {
    data: List<of:Number>

    returns: Dict {
      a: List { Foreach <axon:"data.findAll(isOdd)"> { Bind<axon:"it + 100"> } }
    }
  }
}

//////////////////////////////////////////////////////////////////////////
// Helper Types
//////////////////////////////////////////////////////////////////////////

InterfaceA: Interface {
  m1: Func <new> { returns: Self }
  m9: Func <new> { returns: Self }

  s1: Func <static> { returns: Obj }
  s9: Func <static> { returns: Obj }

  i1: Func { returns: Obj }
  i2: Func <virtual> { returns: Str }
  i9: Func <virtual> { returns: Str }
}

InterfaceB: InterfaceA {
  m1: Func <new> { returns: Self }
  s1: Func <static> { returns: Str }
  i1: Func { returns: Date }
  i2: Str
}

TemplateDictC: {
  a: Str
  b: Str
  c: Str "def-c"
  e: Str?
  f: Str?
}

